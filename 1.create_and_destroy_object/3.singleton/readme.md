## 싱글톤
> 코틀린에서는 본 내용을  고려할 필요성이 없습니다.
> 
> Java에는 존재하지 않는 object 키워드가 단 하나의 인스턴스를 보장합니다.
> ```
> object Singleton{
>   val foo
>   fun bar(){}
> }
> ```
> 예제는 위와 같습니다

싱글톤이랑 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말합니다.

### 싱글톤 구현 방식
-  private 생성자 + public static final 인스턴스
-  private 생성자 + private static final 인스턴스 + public static 접근 메소드
-  enum 타입

첫번 째, 두번 째 방식의 싱글톤은 reflection과 serialize의 예외처리가 필요하다

세번 째 방식으로의 구현은 두 단점을 쉽게 해결할 수 있지만, enum 이외의 클래스를 상속받으려할 때는 불가능한 구현방식이다.

## private 생성자
클래스의 자동생성이나 상속을 막기 위해서는 private 생성자를 활용하자.

유틸리티 클래스는 `모든 멤버들이 static으로 선언된 클래스`로서 인스턴스로 만들어 사용하려는 목적이 아니다. 따라서 원하는 동작 방식을 구현하기 위해서는 `private 생성자`를 활용해야한다.

## 의존 객체 주입
대부분의 클래스는 하나 이상의 클래스에 의존하고 있다. 이러한 타 클래스에 의존하는 형태는 유지보수, 확장성, 테스팅 측면에서 좋지 않다. 타 클래스를 클래스 내부에서 사용해야한다면, 생성자를 활용하여 주입하자. 

## 불필요한 객체 생성을 피하라
- 반복해서 사용될 용의가 있는 구현은 static 객체으로 선언하여, 재사용하자
- 불필요한 오토박싱은 성능을 좋지 않게 만든다

요즘 GC의 높은 성능 덕에, 작은 객체의 회수는 큰 부담이 되지않는다. 생성 코스트가 큰 동작들을 잘 분별하여 적용하자

## 다 쓴 객체 참조를 해제하라
GC는 사용자가 의도치 않게 살려두는 객체를 회수하기 어렵다. 인지적으로 사용하지 않는 객체에 대해서는 null처리를 해주지 않으면, 해당 객체를 참조하고, 해당 객체가 참조하는 모든 객체를 회수할 수 없다. 

### 스택이 메모리 누수에 취약한 이유
스택은 메모리 관리를 본인한다. 스택은 객체의 참조를 담는 elements 배열로 pool을 구성하여 원소를 관리한다. 따라서 참조하는 모든 객체는 유효한 객체이다. 사용자가 null로 해제해주지 않으면 gc의 대상으로 관리하지 않는다.

## finalizer와 cleaner 사용을 피하라
자바는 전적으로 객체의 회수를 GC가 전담해서 하기 때문에, c++의 소멸자와 같이 비할당 객체의 dealloc을 담당하는 방법은 따로 존재하지 않는다. 이러한 비슷한 동작을 수행하는 것이 finalizer (자바 8 이상에선 cleaner)인데 동작의 시점을 가늠할 수 없기 때문에 객체의 파괴가 무한정 지연될 수 있기 때문에 사용을 피해야한다.

## try-with-resources
자바 라이브러리에는 close()를 활용하여 직접 닫아야하는 클래스들이 많이 있다. 사용자가 이를 놓칠 수 있기 때문에 finalizer를 사용하고 있지만 finalizer의 실행을 보장할 수 없기 때문에, try-finally를 사용해왔다. 